/**
 * Copyright 2018 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <getopt.h>
#include <unistd.h>

#include <libparodus.h>
#include <msgpack.h>

#include <stdarg.h>
#include <cimplog/cimplog.h>
#include <cJSON.h>

/*----------------------------------------------------------------------------*/
/*                                   Macros                                   */
/*----------------------------------------------------------------------------*/
#define debug_error(...)      cimplog_error("printer", __VA_ARGS__)
#define debug_info(...)       cimplog_info("printer", __VA_ARGS__)
#define debug_print(...)      cimplog_debug("printer", __VA_ARGS__)


#define SERVICE_NAME "printer"
#define CONTENT_TYPE_JSON  "application/json"

static void sig_handler(int sig);
static int main_loop(libpd_cfg_t *cfg, bool isSubscribed);
static void _help(char *, char *);
static int wait_time = 60 * 1000; // One minute
void subscribeToEvent(char *regex, const char *service_name);
libpd_instance_t hpd_instance;
static char *mac_address;

int main( int argc, char **argv)
{
    const char *option_string = "p:c:w:d:f:m:t:h:n:u::";
    static const struct option options[] = {
        { "help",         optional_argument, 0, 'h' },
        { "parodus-url",  required_argument, 0, 'p' },
        { "client-url",   required_argument, 0, 'c' },
        { "mac-address",  optional_argument, 0, 'm'},
        { "wait-time",    required_argument, 0, 't'},
        { "service-name", required_argument, 0, 'n'},
        { "un-subscribe", no_argument,       0, 'u'},
        { 0, 0, 0, 0 }
    };

    libpd_cfg_t cfg = { .service_name = NULL,
                        .receive = true,
                        .keepalive_timeout_secs = 64,
                        .parodus_url = NULL,
                        .client_url = NULL
                      };

    int item = 0;
    int opt_index = 0;
    int rv = 0;
    bool isSubscribed = true;

    signal(SIGTERM, sig_handler);
    signal(SIGINT, sig_handler);
    signal(SIGUSR1, sig_handler);
    signal(SIGUSR2, sig_handler);
    signal(SIGSEGV, sig_handler);
    signal(SIGBUS, sig_handler);
    signal(SIGKILL, sig_handler);
    signal(SIGFPE, sig_handler);
    signal(SIGILL, sig_handler);
    signal(SIGQUIT, sig_handler);
    signal(SIGHUP, sig_handler);
    signal(SIGALRM, sig_handler);

    mac_address = NULL;
    
    while( -1 != (item = getopt_long(argc, argv, option_string, options, &opt_index)) ) {
        switch( item ) {
            case 'p':
                cfg.parodus_url = strdup(optarg);
                break;
            case 'c':
                cfg.client_url = strdup(optarg);
                break;
            case 'h':
                _help(argv[0], optarg);
                break;
	    case 'm':
                mac_address = strdup(optarg);
            break;
            case 't':
                {
                    int val = atoi(optarg);
                    if (val > 0) {
                      wait_time = val;
                    }
                }
                break;
            case 'n':
                cfg.service_name = strdup(optarg);
                break;
            case 's':
                isSubscribed = true;
                break;
            case 'u':
                isSubscribed = false;
                break;
            case '?':
                if (strchr(option_string, optopt)) {
                    debug_info("%s Option %c requires an argument!\n", argv[0], optopt);
                    _help(argv[0], NULL);
                    rv = -7;
                    break;
                } else {
                    debug_info("%s Unrecognized option %c\n", argv[0], optopt);
                  }

                break;

            default:
                break;
        }
    }

    if( (rv == 0) &&
        (NULL != cfg.parodus_url) &&
        (NULL != cfg.client_url))
    { 
	    if (NULL == mac_address) {
                mac_address = strdup("14cfe1234567");
	    }

	    if(NULL == cfg.service_name)
	    {
	        cfg.service_name = strdup(SERVICE_NAME);
	    }
        main_loop(&cfg, isSubscribed);
        rv = 0;
    } else {
        if ((NULL == cfg.parodus_url)) {
            debug_error("%s parodus_url not specified!\n", argv[0]);
            rv = -1;
        }
        if ((NULL == cfg.client_url)) {
            debug_error("%s client_url not specified !\n", argv[0]);
            rv = -2;
        }
     }
    
    if (rv != 0) {
        debug_error("%s  program terminating\n", argv[0]);
    }

    if( NULL != cfg.parodus_url )   free( (char*) cfg.parodus_url );
    if( NULL != cfg.client_url )    free( (char*) cfg.client_url );
    if( NULL != mac_address ) free((char *) mac_address);

    return rv;
}

static void sig_handler(int sig)
{
    if( sig == SIGINT ) {
        debug_info("SIGINT received! Program Terminating!\n");
        exit(0);
    } else if ( sig == SIGTERM ) {
        debug_info("SIGTERM received! Program Terminating!\n");
        exit(0);
    } else if( sig == SIGUSR1 ) {
        signal(SIGUSR1, sig_handler); /* reset it to this function */
        debug_info("SIGUSR1 received!\n");
    } else if( sig == SIGUSR2 ) {
        signal(SIGUSR2, sig_handler);
        debug_info("SIGUSR2 received!\n");
    } else if( sig == SIGCHLD ) {
        signal(SIGCHLD, sig_handler); /* reset it to this function */
        debug_info("SIGHLD received!\n");
    } else if( sig == SIGPIPE ) {
        signal(SIGPIPE, sig_handler); /* reset it to this function */
        debug_info("SIGPIPE received!\n");
    } else if( sig == SIGALRM ) {
        signal(SIGALRM, sig_handler); /* reset it to this function */
        debug_info("SIGALRM received!\n");
    } else {
        debug_info("Signal %d received!\n", sig);
        exit(0);
    }
}

void subscribeToEvent(char *regex, const char *service_name){

	wrp_msg_t *res_wrp_msg = NULL;
	cJSON *response = NULL;
	char * str = NULL;
	char *contentType = NULL;
	int sendStatus;
	char source[128];
	char dest[128];

	res_wrp_msg = (wrp_msg_t *) malloc(sizeof(wrp_msg_t));
	if (res_wrp_msg)
	{
		memset(res_wrp_msg, 0, sizeof(wrp_msg_t));
	}
	else
	{
		debug_error("In subscribeToEvent() - malloc Failed !!!");
	}
	
	snprintf(source,127,"mac:%s/%s", mac_address, service_name);
	snprintf(dest,127,"mac:%s/%s/%s", mac_address, "parodus","subscribe");
	debug_print("source is %s\n",source);
	debug_print("dest is %s\n",dest);	
	response = cJSON_CreateObject();
	//cJSON_AddItemToObject(response, service_name, parameters = cJSON_CreateObject());
	cJSON_AddStringToObject(response, service_name, regex);

	str = cJSON_PrintUnformatted(response);
    debug_info("Payload Response: %s\n", str);

	res_wrp_msg->msg_type = WRP_MSG_TYPE__CREATE;
	res_wrp_msg->u.crud.payload = (void *)str;
	res_wrp_msg->u.crud.payload_size = strlen(str);
	res_wrp_msg->u.crud.source = strdup(source);
	res_wrp_msg->u.crud.dest = strdup(dest);
	res_wrp_msg->u.crud.transaction_uuid = "c07ee5e1-70be-444c-a156-097c767ad8aa";
	res_wrp_msg->u.crud.status = 1;
	res_wrp_msg->u.crud.rdr = 0;
	contentType = (char *) malloc(sizeof(char) * (strlen(CONTENT_TYPE_JSON) + 1));
	if (contentType)
	{
		strncpy(contentType, CONTENT_TYPE_JSON, strlen(CONTENT_TYPE_JSON) + 1);
		res_wrp_msg->u.crud.content_type = contentType;
	}
	else
	{
		free(res_wrp_msg);
		debug_error("In subscribeToEvent() - malloc Failed !!!");
	}

	sendStatus = libparodus_send(hpd_instance, res_wrp_msg);
	debug_print("sendStatus is %d\n", sendStatus);
	if (sendStatus == 0)
	{
		debug_info("Sent message successfully to parodus\n");
	}
	else
	{
		debug_error("libparodus_send() Failed to send message: '%s'\n", libparodus_strerror(sendStatus));
	}
}

static int main_loop(libpd_cfg_t *cfg, bool isSubscribed)
{
    int rv;
    wrp_msg_t *wrp_msg;
    int backoff_retry_time = 0;
    int max_retry_sleep = (1 << 9) - 1;
    int c = 2;

    while( true ) {
        rv = libparodus_init( &hpd_instance, cfg );
        if( 0 != rv ) {
            debug_info("Init for parodus (url %s): %d '%s'\n", cfg->parodus_url, rv, libparodus_strerror(rv) );
            backoff_retry_time = (1 << c) - 1;
            sleep(backoff_retry_time);
            c++;

            if( backoff_retry_time >= max_retry_sleep ) {
                c = 2;
                backoff_retry_time = 0;
            }
        } else {
            debug_info("%s service registered with libparodus url %s\n", cfg->service_name, cfg->parodus_url);
            break;
        }
        libparodus_shutdown(&hpd_instance);
    }

    if(isSubscribed == true)
    {
        //Subscribe to event
        subscribeToEvent("node-change", cfg->service_name);
    }

    debug_print("starting the main loop...\n");
    while( true ) {
        rv = libparodus_receive(hpd_instance, &wrp_msg, wait_time);

        if( 0 == rv ) {
            char *bytes = NULL;
            ssize_t n = wrp_struct_to(wrp_msg, WRP_STRING, (void **) &bytes);
            if (n > 0) {
                debug_print("\n%s", bytes);
		debug_info("wrp_msg->u.event.payload %s\n",(char *)wrp_msg->u.event.payload);
                free(bytes);
            } else {
                debug_print("Service Printer Memory Error on WRP message conversion\n");
		debug_print("wrp_msg->src %s\n",(char *)wrp_msg->u.crud.source);
                debug_print("wrp_msg->dest %s\n",(char *)wrp_msg->u.crud.dest);                
                debug_print("wrp_msg->u.req.payload %s\n",(char *)wrp_msg->u.crud.payload);
            }
            
        } else if( 1 == rv || 2 == rv ) {
            debug_print("Timed out or message closed.\n");
            continue;
        } else {
            debug_error("Libparodus failed to receive message: '%s'\n",libparodus_strerror(rv));
        }

        if( (NULL != wrp_msg) && (2 != rv) ) {
            wrp_free_struct(wrp_msg);
            wrp_msg = NULL;
        }
    }

    (void ) libparodus_shutdown(&hpd_instance);
    debug_print("End of printer\n");
    return 0;
}

void _help(char *a, char *b)
{
    (void ) a; (void ) b;
    
    // stub
}
